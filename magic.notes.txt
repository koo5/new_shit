how reparsing could work:
lets presume sequences (like for List) are transformed into recursions of Syntaxed
we are generating a marpa grammar for syntaxed as we are now, but:
we go until first Reparse tag. We proceed until first Child tag after that. Before the child tag:
we generate first rule: rhs is what we've seen up until now, perhaps: ["for", <vardecl>, "in"]. *
lhs: look up or generate a new symbol for the For node parsed up until the first reparse.

we go until the second need for reparse, and create a new rule, we create the lhs the same way, but rhs:
for the part up until the first need for reparse, we dont use the "half parsed For", we just generated, instead, 
we use the rhs of the first rule, that is, the symbols for the syntax tags themselves. This ensures that
it is not possible to go on parsing the whole For, but only the part until the first need for reparse.

The action for these rules is creating a For with an indicator that it has been only parsed up until the respective reparse.
or rather, the action creates a new Parser, with the half-parsed For followed by the unparsed text

when collecting grammar, the half-parsed For is put into the marpa input stream as the constituent tag symbols



* this can probably be simplified to assume any child tag means a need for reparse



	"""
		statement_followed_by_parser = m.symbol('statement_followed_by_parser')
		m.rule('statement_followed_by_parser', statement_followed_by_parser, [B.statement, parser])
		m.sequence('optionally_elements_followed_by_parser', optionally_elements_followed_by_parser, B.anything.symbol, ident_list, m.maybe_whitespace, 0)
		m.sequence('optionally_elements', optionally_elements, B.anything.symbol, ident_list, m.maybe_whitespace, 0)
		r = m.symbol('Statements literal head')
		m.rule('statements literal head', r, [m.maybe_whitespace, m.known_char('{'), m.maybe_whitespace, m.known_char('}')], empty_statements_body_from_parse)
		return r
	"""
